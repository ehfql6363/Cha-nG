package com.ssafy.chaing.payment.service;

import com.ssafy.chaing.common.exception.BadRequestException;
import com.ssafy.chaing.common.exception.ExceptionCode;
import com.ssafy.chaing.common.exception.NotFoundException;
import com.ssafy.chaing.contract.domain.ContractEntity;
import com.ssafy.chaing.contract.domain.ContractUserEntity;
import com.ssafy.chaing.contract.repository.ContractRepository;
import com.ssafy.chaing.contract.repository.ContractUserRepository;
import com.ssafy.chaing.fintech.controller.request.TransferCommand;
import com.ssafy.chaing.fintech.service.FintechService;
import com.ssafy.chaing.fintech.service.dto.TransferDTO;
import com.ssafy.chaing.group.domain.GroupEntity;
import com.ssafy.chaing.group.repository.GroupRepository;
import com.ssafy.chaing.notification.domain.NotificationCategory;
import com.ssafy.chaing.notification.service.NotificationService;
import com.ssafy.chaing.payment.controller.response.AccountInfoResponse;
import com.ssafy.chaing.payment.controller.response.PaymentStatusInfoResponse;
import com.ssafy.chaing.payment.domain.FeeType;
import com.ssafy.chaing.payment.domain.PaymentEntity;
import com.ssafy.chaing.payment.domain.PaymentStatus;
import com.ssafy.chaing.payment.domain.UserPaymentEntity;
import com.ssafy.chaing.payment.repository.PaymentRepository;
import com.ssafy.chaing.payment.repository.UserPaymentRepository;
import com.ssafy.chaing.payment.service.command.RetrieveRentCommand;
import com.ssafy.chaing.payment.service.command.RetrieveUtilityCommand;
import com.ssafy.chaing.payment.service.command.TransferRentCommand;
import com.ssafy.chaing.payment.service.dto.CurrentPaymentDTO;
import com.ssafy.chaing.payment.service.dto.MonthPaymentDTO;
import com.ssafy.chaing.payment.service.dto.PaymentOverviewDTO;
import com.ssafy.chaing.payment.service.dto.RetrieveRentDTO;
import com.ssafy.chaing.payment.service.dto.RetrieveUtilityDTO;
import com.ssafy.chaing.payment.service.dto.WeekPaymentDTO;
import com.ssafy.chaing.user.domain.UserEntity;
import com.ssafy.chaing.user.repository.UserRepository;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
public class PaymentServiceImpl implements PaymentService {

    private static final String DATE_FORMAT = "yyyyMM";
    private static final String TIMEZONE = "UTC";

    private final PaymentRepository paymentRepository;
    private final UserRepository userRepository;
    private final GroupRepository groupRepository;
    private final ContractRepository contractRepository;
    private final ContractUserRepository contractUserRepository;
    private final UserPaymentRepository userPaymentRepository;
    private final FintechService fintechService;
    private final NotificationService notificationService;

    @Override
    @Transactional(readOnly = true, rollbackFor = Exception.class)
    public RetrieveRentDTO retrieveRent(RetrieveRentCommand command) {
        Long userId = command.getUserId();
        int year = Integer.valueOf(command.getYear());
        int month = Integer.valueOf(command.getMonth());

        // Í¥ÄÎ†® ÏóîÌã∞Ìã∞ Ï°∞Ìöå
        UserEntity user = getUserEntity(userId);
        GroupEntity group = getGroupEntity(user);
        ContractEntity contract = getContractEntity(group);
        ContractUserEntity contractUser = getContractUserEntity(contract.getId(), userId);

        // Í≤∞Ï†ú Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
        List<PaymentEntity> payments = paymentRepository.findAllByContractIdAndFeeType(contract.getId(), FeeType.RENT);
        int currentMonth = formatToYearMonth(year, month);

        // Í≤∞Ï†ú Ï†ïÎ≥¥ Ï≤òÎ¶¨
        Map<Long, List<UserPaymentEntity>> userPaymentsByPaymentId = getUserPaymentsByPaymentId(payments);

        // ÌòÑÏû¨ Ïõî Í≤∞Ï†ú Ï†ïÎ≥¥
        List<CurrentPaymentDTO> currentMonthPayments = getCurrentMonthPayments(payments, currentMonth,
                userPaymentsByPaymentId);

        // ÏõîÎ≥Ñ Í≤∞Ï†ú ÏöîÏïΩ
        List<MonthPaymentDTO> monthList = getMonthPaymentSummaries(payments, userPaymentsByPaymentId);

        return new RetrieveRentDTO(
                contract.getRentTotalAmount(),
                contractUser.getRentAmount(),
                contract.getDueDate(),
                currentMonthPayments,
                monthList
        );
    }

    @Override
    public AccountInfoResponse getRentAccountNo(Long userId) {
        ContractUserEntity contractUser = contractUserRepository.findByUser_Id(userId)
                .orElseThrow(() -> new BadRequestException(ExceptionCode.CONTRACT_USER_NOT_FOUND));
        String rentAccountNo = contractUser.getContract().getRentAccountNo();
        if (rentAccountNo == null) {
            throw new BadRequestException(ExceptionCode.RENT_ACCOUNT_ALREADY_EXIST);
        }
        return AccountInfoResponse.from(rentAccountNo);
    }

    @Override
    @Transactional
    public void transferToOwner(TransferRentCommand command) {

        UserEntity user = getUserEntity(command.getUserId());
        GroupEntity group = getGroupEntity(user);
        ContractEntity contract = getContractEntity(group);
        ContractUserEntity contractUser = getContractUserEntity(contract.getId(), command.getUserId());

        int targetMonth = command.getMonth(); // ex: 202510
        FeeType feeType = FeeType.RENT;

        PaymentEntity payment = paymentRepository
                .findWithUsersByContractIdAndMonthAndFeeType(contract.getId(), targetMonth, feeType)
                .orElseThrow(() -> new NotFoundException(ExceptionCode.USER_PAYMENT_NOT_FOUND));

        if (payment.getStatus().equals(PaymentStatus.PAID)) {
            throw new BadRequestException(ExceptionCode.ALREADY_PAID);
        }

        if (!payment.getStatus().equals(PaymentStatus.COLLECTED)) {
            throw new BadRequestException(ExceptionCode.PAY_NOT_COLLECTED);
        }

        TransferCommand dto = new TransferCommand(
                payment.getId(),
                payment.getContract().getId(),
                (long) payment.getMonth(),
                group.getName() + "Ïùò ÎåÄÌëú Í≥ÑÏ¢å: " + contract.getRentAccountNo().substring(0, 4),
                contract.getRentAccountNo(),
                group.getName() + "Ïùò ÏßëÏ£ºÏù∏ Í≥ÑÏ¢å: " + contract.getOwnerAccountNo().substring(0, 4),
                contract.getOwnerAccountNo(),
                payment.getTotalAmount(),
                false,
                ZonedDateTime.now(ZoneId.of("Asia/Seoul")).toString(),
                payment.getFeeType(),
                group.getId(),
                null
        );

        TransferDTO result = fintechService.rentTransfer(dto);

        if (!result.isSuccess()) {
            throw new BadRequestException(ExceptionCode.FINTECH_TRANSFER_FAILED);
        }

        payment.updatePaidDate(ZonedDateTime.now(ZoneOffset.UTC));
        payment.setStatus(PaymentStatus.PAID);

        paymentRepository.save(payment);

        log.info("üí∏ Ïú†Ï†Ä ID={} ‚Üí ÏßëÏ£ºÏù∏ÏóêÍ≤å ÏõîÏÑ∏ ÏàòÎèô ÎÇ©Î∂Ä ÏôÑÎ£å. PaymentID={}",
                user.getId(), payment.getId());

        List<UserEntity> members = userRepository.findAllUsersInSameContract(command.getUserId());

        for (UserEntity member : members) {
            notificationService.sendNotification(
                    member.getId(),
                    "ÏõîÏÑ∏ ÏÜ°Í∏à ÏôÑÎ£å",
                    command.getBalance() + "ÏõêÏù¥ ÏûÑÎåÄÏù∏ÏóêÍ≤å ÏÜ°Í∏àÎêòÏóàÏäµÎãàÎã§.",
                    NotificationCategory.PAYMENT
            );
        }
    }

    @Override
    @Transactional
    public void depositToRentAccount(TransferRentCommand command) {

        UserEntity user = getUserEntity(command.getUserId());
        GroupEntity group = getGroupEntity(user);
        ContractEntity contract = getContractEntity(group);
        ContractUserEntity contractUser = getContractUserEntity(contract.getId(), command.getUserId());

        int targetMonth = command.getMonth(); // ex: 202510
        FeeType feeType = FeeType.RENT;

        PaymentEntity payment = paymentRepository
                .findWithUsersByContractIdAndMonthAndFeeType(contract.getId(), targetMonth, feeType)
                .orElseThrow(() -> new NotFoundException(ExceptionCode.USER_PAYMENT_NOT_FOUND));

        // ÏÇ¨Ïö©ÏûêÏóê ÎåÄÌïú UserPaymentEntity Ï°∞Ìöå
        UserPaymentEntity userPayment = userPaymentRepository
                .findByPaymentIdAndContractMemberId(payment.getId(), contractUser.getId())
                .orElseThrow(() -> new NotFoundException(ExceptionCode.USER_PAYMENT_NOT_FOUND));

        // Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Í≤ΩÏö∞ Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄ
        if (userPayment.getStatus() == PaymentStatus.PAID || userPayment.getStatus() == PaymentStatus.COLLECTED) {
            throw new BadRequestException(ExceptionCode.ALREADY_PAID);
        }

        // ÏÜ°Í∏à: ÏöîÏ≤≠ÏûêÍ∞Ä Î≥∏Ïù∏ Í≥ÑÏ¢åÏóêÏÑú ‚Üí ÏõîÏÑ∏ Í≥ÑÏ¢åÎ°ú ÏÜ°Í∏à
        TransferDTO result = fintechService.rentTransfer(
                new TransferCommand(
                        userPayment.getId(),
                        contract.getId(),
                        (long) payment.getMonth(),
                        user.getName() + "Ïùò Í≥ÑÏ¢å: " + contractUser.getAccountNo().substring(0, 4),
                        contractUser.getAccountNo(),
                        payment.getContract().getGroup().getName() + "Ïùò Í≥µÎèô Í≥ÑÏ¢å: " + payment.getContract()
                                .getRentAccountNo().substring(0, 4),
                        payment.getContract().getRentAccountNo(),
                        command.getBalance(),
                        payment.getStatus() == PaymentStatus.COLLECTED,
                        ZonedDateTime.now(ZoneId.of("Asia/Seoul")).toString(),
                        payment.getFeeType(),
                        null,
                        user.getId()
                )
        );

        if (!result.isSuccess()) {
            throw new BadRequestException(ExceptionCode.FINTECH_TRANSFER_FAILED);
        }

        payment.addPaidAmount(userPayment.getAmount());
        userPayment.updateStatus(PaymentStatus.COLLECTED);
        userPaymentRepository.save(userPayment);

        List<UserEntity> members = userRepository.findAllUsersInSameContract(command.getUserId());

        for (UserEntity member : members) {
            notificationService.sendNotification(
                    member.getId(),
                    "ÏÉùÌôúÎπÑ ÏûÖÍ∏à ÏôÑÎ£å",
                    command.getBalance() + "ÏõêÏù¥ ÏÉùÌôúÎπÑ Í≥ÑÏ¢åÏóê ÏûÖÍ∏àÎêòÏóàÏäµÎãàÎã§.",
                    NotificationCategory.PAYMENT
            );
        }

        log.info("üí∏ Ïú†Ï†Ä ID={} ‚Üí ÏõîÏÑ∏ ÏàòÎèô ÎÇ©Î∂Ä ÏôÑÎ£å. PaymentID={}, UserPaymentID={}",
                user.getId(), payment.getId(), userPayment.getId());

    }

    @Override
    @Transactional(readOnly = true, rollbackFor = Exception.class)
    public RetrieveUtilityDTO retrieveUtility(RetrieveUtilityCommand command) {
        Long userId = command.getUserId();
        // year, month ÌååÎùºÎØ∏ÌÑ∞Îäî Îçî Ïù¥ÏÉÅ ÏßÅÏ†ë ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå (Ìï≠ÏÉÅ ÏµúÏã† Í∏∞Ï§Ä 6Ï£º)

        // Í¥ÄÎ†® ÏóîÌã∞Ìã∞ Ï°∞Ìöå
        UserEntity user = getUserEntity(userId);
        GroupEntity group = getGroupEntity(user);
        ContractEntity contract = getContractEntity(group);

        // Ìï¥Îãπ Í≥ÑÏïΩÏùò Î™®Îì† Í≥µÍ≥ºÍ∏à Í≤∞Ï†ú Ï†ïÎ≥¥ Ï°∞Ìöå (ÏµúÏã†Ïàú Ï†ïÎ†¨)
        List<PaymentEntity> allUtilityPayments = paymentRepository.findAllByContractIdAndFeeTypeOrderByMonthDescWeekDesc(
                contract.getId(),
                FeeType.UTILITY
        );

        if (allUtilityPayments.isEmpty()) {
            // Í≥µÍ≥ºÍ∏à ÎÇ¥Ïó≠Ïù¥ ÏóÜÏúºÎ©¥ Îπà ÏùëÎãµ Î∞òÌôò ÎòêÎäî Í∏∞Î≥∏Í∞í Ï≤òÎ¶¨
            return new RetrieveUtilityDTO(
                    0, // ÎòêÎäî 0
                    0, // myAmount
                    Collections.emptyList(), // currentWeekPayments
                    Collections.emptyList()  // weekList
            );
        }

        // Î™®Îì† Í¥ÄÎ†® UserPayment Ï†ïÎ≥¥ Ï°∞Ìöå
        Map<Long, List<UserPaymentEntity>> userPaymentsByPaymentId = getUserPaymentsByPaymentId(allUtilityPayments);

        // ÌòÑÏû¨ Ï£º(Í∞ÄÏû• ÏµúÏã† Ï£º) Í≤∞Ï†ú Ï†ïÎ≥¥ Í≥ÑÏÇ∞ (Ïù¥Ï†Ñ Î°úÏßÅÍ≥º Í±∞Ïùò ÎèôÏùº, ÏûÖÎ†• Î¶¨Ïä§Ìä∏Îßå Î≥ÄÍ≤ΩÎê®)
        List<CurrentPaymentDTO> currentWeekPayments = getCurrentWeekUtilityPayments(
                allUtilityPayments, userPaymentsByPaymentId); // Ïù¥Ï†ú Ï†ÑÏ≤¥ Î¶¨Ïä§Ìä∏Î•º Î∞õÏïÑÏÑú ÎÇ¥Î∂ÄÏóêÏÑú ÏµúÏã† Ï£º ÌïÑÌÑ∞ÎßÅ

        int totalAmount = currentWeekPayments.stream()
                .map(CurrentPaymentDTO::getAmount)
                .reduce(0, Integer::sum);

        // ÎÇ¥ Í∏àÏï° Í≥ÑÏÇ∞ (ÌòÑÏû¨ Ï£ºÏóê ÎåÄÌï¥)
        int myAmount = currentWeekPayments.stream()
                .filter(payment -> payment.getUserId().equals(userId))
                .mapToInt(CurrentPaymentDTO::getAmount)
                .sum();

        // Ï£ºÎ≥Ñ Í≤∞Ï†ú ÏöîÏïΩ (ÏßÄÎÇú 6Ï£º)
        List<WeekPaymentDTO> weekList = getWeekPaymentSummaries(allUtilityPayments,
                userPaymentsByPaymentId); // Ï†ÑÏ≤¥ Î¶¨Ïä§Ìä∏ÏôÄ userPayment Îßµ Ï†ÑÎã¨

        return new RetrieveUtilityDTO(
                totalAmount, // ÌïÑÏöîÏãú Í≥µÍ≥ºÍ∏à Ï¥ùÏï° ÌïÑÎìú Ï∂îÍ∞Ä Í≥†Î†§
                myAmount,
                currentWeekPayments,
                weekList
        );
    }

    @Transactional
    public PaymentEntity createPayment(ContractEntity contract, ZonedDateTime ownerExecution) {

        PaymentEntity payment = PaymentEntity.builder()
                .contract(contract)
                .month(ownerExecution.getYear() * 100 + ownerExecution.getMonthValue())
                .feeType(FeeType.RENT)
                .totalAmount(contract.getRentTotalAmount())
                .status(PaymentStatus.STARTED)
                .paidAmount(0)
                .retryCount(0)
                .build();

        payment.setNextExecutionDate(ownerExecution);
        PaymentEntity savedPayment = paymentRepository.save(payment);

        for (ContractUserEntity member : contract.getMembers()) {
            UserPaymentEntity userPayment = UserPaymentEntity.builder()
                    .payment(payment)
                    .contractMember(member)
                    .amount(member.getRentAmount())
                    .status(PaymentStatus.PENDING)
                    .build();
            userPaymentRepository.save(userPayment);
        }

        return savedPayment;

    }

    @Override
    public PaymentOverviewDTO getPaymentOverview(Long userId) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BadRequestException(ExceptionCode.USER_NOT_FOUND));

        GroupEntity group = groupRepository.findById(user.getGroupId())
                .orElseThrow(() -> new BadRequestException(ExceptionCode.GROUP_NOT_FOUND));

        boolean rentPaid = true;
        boolean userRentPaid = true;
        boolean utilityPaid = true;
        boolean userUtilityPaid = true;

        // contractIdÍ∞Ä nullÏù¥Í±∞ÎÇò Ï°∞Ìöå Ïã§Ìå®ÌïòÎ©¥ Í∏∞Î≥∏ ÏÉÅÌÉúÎ°ú Î¶¨ÌÑ¥
        Long contractId = group.getContractId();
        if (contractId == null) {
            return new PaymentOverviewDTO(group.getName(), rentPaid, userRentPaid, utilityPaid, userUtilityPaid);
        }

        ContractEntity contract = contractRepository.findById(contractId).orElse(null);
        if (contract == null) {
            return new PaymentOverviewDTO(group.getName(), rentPaid, userRentPaid, utilityPaid, userUtilityPaid);
        }

        ContractUserEntity contractUser = contractUserRepository
                .findByContractIdAndUserId(contract.getId(), userId)
                .orElse(null);

        if (contractUser == null) {
            return new PaymentOverviewDTO(group.getName(), rentPaid, userRentPaid, utilityPaid, userUtilityPaid);
        }

        Integer dueDate = contract.getDueDate();

        if (dueDate == null) {
            return new PaymentOverviewDTO(group.getName(), rentPaid, userRentPaid, utilityPaid, userUtilityPaid);
        }

        int targetMonth = calculateTargetMonthByDueDate(dueDate);

        PaymentEntity rentPayment = paymentRepository
                .findWithUsersByContractIdAndMonthAndFeeType(contract.getId(), targetMonth, FeeType.RENT)
                .orElse(null);

        if (rentPayment != null &&
                (
                        rentPayment.getStatus() == PaymentStatus.PARTIALLY_PAID
                                || rentPayment.getStatus() == PaymentStatus.FAILED
                )
        ) {
            rentPaid = false;
        }

        UserPaymentEntity rentUserPayment = rentPayment != null
                ? userPaymentRepository.findByPaymentIdAndContractMemberId(rentPayment.getId(), contractUser.getId())
                .orElse(null)
                : null;

        if (rentUserPayment != null && rentUserPayment.getStatus() == PaymentStatus.FAILED) {
            userRentPaid = false;
        }

        PaymentEntity utilityPayment = paymentRepository
                .findTopByContractIdAndFeeTypeOrderByMonthDescWeekDesc(contract.getId(), FeeType.UTILITY)
                .orElse(null);

        if (utilityPayment != null &&
                (
                        utilityPayment.getStatus() == PaymentStatus.PARTIALLY_PAID
                                || utilityPayment.getStatus() == PaymentStatus.FAILED
                )) {
            utilityPaid = false;
        }

        UserPaymentEntity utilityUserPayment = utilityPayment != null
                ? userPaymentRepository.findByPaymentIdAndContractMemberId(utilityPayment.getId(), contractUser.getId())
                .orElse(null)
                : null;

        if (utilityUserPayment != null && utilityUserPayment.getStatus() == PaymentStatus.FAILED) {
            userUtilityPaid = false;
        }

        return new PaymentOverviewDTO(
                group.getName(),
                rentPaid,
                userRentPaid,
                utilityPaid,
                userUtilityPaid
        );
    }

    @Override
    public PaymentStatusInfoResponse getCurrentPaymentStatus(Long userId, int month) {
        UserEntity user = userRepository.findById(userId)
                .orElseThrow(() -> new BadRequestException(ExceptionCode.USER_NOT_FOUND));

        GroupEntity group = groupRepository.findById(user.getGroupId())
                .orElseThrow(() -> new BadRequestException(ExceptionCode.GROUP_NOT_FOUND));

        Long contractId = group.getContractId();
        if (contractId == null) {
            return new PaymentStatusInfoResponse(null, null, null, null);
        }

        ContractEntity contract = contractRepository.findById(contractId)
                .orElse(null);

        if (contract == null) {
            return new PaymentStatusInfoResponse(null, null, null, null);
        }

        ContractUserEntity contractUser = contractUserRepository
                .findByContractIdAndUserId(contract.getId(), userId)
                .orElse(null);

        if (contractUser == null) {
            return new PaymentStatusInfoResponse(null, null, null, null);
        }

        // RENT
        PaymentEntity rentPayment = paymentRepository
                .findWithUsersByContractIdAndMonthAndFeeType(contract.getId(), month, FeeType.RENT)
                .orElse(null);

        PaymentStatus rentStatus = rentPayment != null ? rentPayment.getStatus() : null;

        UserPaymentEntity rentUserPayment = rentPayment != null
                ? userPaymentRepository.findByPaymentIdAndContractMemberId(rentPayment.getId(), contractUser.getId())
                .orElse(null)
                : null;

        PaymentStatus userRentStatus = rentUserPayment != null ? rentUserPayment.getStatus() : null;

        // UTILITY
        PaymentEntity utilityPayment = paymentRepository
                .findTopByContractIdAndFeeTypeAndMonthOrderByWeekDesc(contract.getId(), FeeType.UTILITY, month)
                .orElse(null);

        PaymentStatus utilityStatus = utilityPayment != null ? utilityPayment.getStatus() : null;

        UserPaymentEntity utilityUserPayment = utilityPayment != null
                ? userPaymentRepository.findByPaymentIdAndContractMemberId(utilityPayment.getId(), contractUser.getId())
                .orElse(null)
                : null;

        PaymentStatus userUtilityStatus = utilityUserPayment != null ? utilityUserPayment.getStatus() : null;

        return new PaymentStatusInfoResponse(
                rentStatus,
                userRentStatus,
                utilityStatus,
                userUtilityStatus
        );
    }


    private int calculateTargetMonthByDueDate(int dueDateDay) {
        ZonedDateTime nowKST = ZonedDateTime.now(ZoneId.of("Asia/Seoul"));

        int year = nowKST.getYear();
        int month = nowKST.getMonthValue();
        int day = nowKST.getDayOfMonth();

        if (day < dueDateDay) {
            // Ïù¥Ï†Ñ Îã¨Î°ú Ïù¥Îèô
            month -= 1;
            if (month == 0) {
                month = 12;
                year -= 1;
            }
        }

        return year * 100 + month; // yyyyMM ÌòïÏãùÏúºÎ°ú Î∞òÌôò
    }

    private UserEntity getUserEntity(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new BadRequestException(ExceptionCode.USER_NOT_FOUND));
    }

    private GroupEntity getGroupEntity(UserEntity user) {
        log.info("user group is = {} ", user.getGroupId());
        return groupRepository.findById(user.getGroupId())
                .orElseThrow(() -> new BadRequestException(ExceptionCode.GROUP_NOT_FOUND));
    }

    private ContractEntity getContractEntity(GroupEntity group) {
        return contractRepository.findById(group.getContractId())
                .orElseThrow(() -> new BadRequestException(ExceptionCode.CONTRACT_NOT_FOUND));
    }

    private ContractUserEntity getContractUserEntity(Long contractId, Long userId) {
        return contractUserRepository.findByContractIdAndUserId(contractId, userId)
                .orElseThrow(() -> new BadRequestException(ExceptionCode.USER_NOT_FOUND));
    }

    private int getCurrentMonth() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(DATE_FORMAT);
        return Integer.parseInt(ZonedDateTime.now(ZoneId.of(TIMEZONE)).format(formatter));
    }

    // yearÏôÄ monthÎ•º yyyyMM ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÌïòÎäî Î©îÏÑúÎìú Ï∂îÍ∞Ä
    private int formatToYearMonth(Integer year, Integer month) {
        // yearÎÇò monthÍ∞Ä nullÏù¥Î©¥ ÌòÑÏû¨ ÏãúÍ∞Ñ Ï†ïÎ≥¥Î°ú ÎåÄÏ≤¥
        if (year == null || month == null) {
            return getCurrentMonth(); // Í∏∞Ï°¥ Î©îÏÑúÎìú ÌôúÏö©
        }

        if (year < 1000 || year > 9999) {
            throw new BadRequestException(ExceptionCode.INVALID_YEAR);
        }

        if (month < 1 || month > 12) {
            throw new BadRequestException(ExceptionCode.INVALID_MONTH);
        }

        // ÏõîÏù¥ 1~9Ïù∏ Í≤ΩÏö∞ ÏïûÏóê 0ÏùÑ Î∂ôÏûÑ
        String monthStr = month < 10 ? "0" + month : String.valueOf(month);
        return Integer.parseInt(year + monthStr);
    }

    private Map<Long, List<UserPaymentEntity>> getUserPaymentsByPaymentId(List<PaymentEntity> payments) {
        List<Long> allPaymentIds = payments.stream()
                .map(PaymentEntity::getId)
                .collect(Collectors.toList());

        List<UserPaymentEntity> allUserPayments = userPaymentRepository.findAllByPaymentIdIn(allPaymentIds);

        return allUserPayments.stream()
                .collect(Collectors.groupingBy(up -> up.getPayment().getId()));
    }

    private List<CurrentPaymentDTO> getCurrentMonthPayments(
            final List<PaymentEntity> payments,
            final int currentMonth,
            final Map<Long, List<UserPaymentEntity>> userPaymentsByPaymentId) {

        return payments.stream()
                .filter(payment -> payment.getMonth() == currentMonth)
                .flatMap(payment -> {
                    List<UserPaymentEntity> userPayments = userPaymentsByPaymentId.getOrDefault(payment.getId(),
                            List.of());
                    if (userPayments.isEmpty()) {
                        throw new BadRequestException(ExceptionCode.USER_PAYMENT_NOT_FOUND);
                    }

                    return userPayments.stream()
                            .map(up -> new CurrentPaymentDTO(
                                    up.getContractMember().getUser().getId(),
                                    up.getAmount(),
                                    up.getStatus() == PaymentStatus.COLLECTED
                            ));
                })
                .collect(Collectors.toList());
    }

    private List<CurrentPaymentDTO> getCurrentWeekUtilityPayments(
            final List<PaymentEntity> sortedAllPayments, // Ïù¥Î¶Ñ Î≥ÄÍ≤Ω: allUtilityPayments -> sortedAllPayments
            final Map<Long, List<UserPaymentEntity>> userPaymentsByPaymentId) {

        // Í∞ÄÏû• ÏµúÏã† Ï£º Ï∞æÍ∏∞ (Ï†ïÎ†¨Îêú Î¶¨Ïä§Ìä∏ÏóêÏÑú Ï≤´ Î≤àÏß∏ Ìï≠Î™©Ïùò Ï£º)
        if (sortedAllPayments.isEmpty()) {
            return Collections.emptyList();
        }

        // Ï†ïÎ†¨ÎêòÏñ¥ ÏûàÏúºÎØÄÎ°ú Ï≤´Î≤àÏß∏ Ìï≠Î™©Ïù¥ Í∞ÄÏû• ÏµúÏã† Îç∞Ïù¥ÌÑ∞
        PaymentEntity latestPayment = sortedAllPayments.getFirst();
        int latestMonth = latestPayment.getMonth();
        int latestWeek = latestPayment.getWeek();

        // ÏµúÏã† Ïõî/Ï£ºÏóê Ìï¥ÎãπÌïòÎäî PaymentEntity ÌïÑÌÑ∞ÎßÅ
        return sortedAllPayments.stream()
                .filter(payment -> payment.getMonth() == latestMonth
                        && payment.getWeek() == latestWeek) // ÌòÑÏû¨ Ïõî/Ï£º Îç∞Ïù¥ÌÑ∞Îßå ÌïÑÌÑ∞ÎßÅ
                .flatMap(payment -> {
                    List<UserPaymentEntity> userPayments = userPaymentsByPaymentId.getOrDefault(payment.getId(),
                            List.of());
                    // userPaymentsÍ∞Ä ÎπÑÏñ¥ÏûàÎäî Í≤ΩÏö∞Îäî Îç∞Ïù¥ÌÑ∞ Ï†ïÌï©ÏÑ± Î¨∏Ï†úÏùº Ïàò ÏûàÏùå (Î°úÍπÖ ÎòêÎäî ÏòàÏô∏ Ï≤òÎ¶¨ Í≥†Î†§)
                    if (userPayments.isEmpty()) {
                        log.warn("UserPayments not found for Payment ID: {}", payment.getId());
                        // ÌòπÏùÄ throw new NotFoundException(...) Îì±
                        return Stream.empty(); // ÏùºÎã® ÎπÑÏñ¥ÏûàÎäî Ïä§Ìä∏Î¶º Î∞òÌôò
                    }

                    return userPayments.stream()
                            .map(up -> new CurrentPaymentDTO(
                                    up.getContractMember().getUser().getId(),
                                    up.getAmount(),
                                    up.getStatus() == PaymentStatus.COLLECTED || up.getStatus() == PaymentStatus.PAID
                                    // COLLECTED ÎòêÎäî PAID ÏÉÅÌÉúÎ•º ÏôÑÎ£åÎ°ú Í∞ÑÏ£º
                            ));
                })
                .collect(Collectors.toList());
    }

    private List<MonthPaymentDTO> getMonthPaymentSummaries(
            final List<PaymentEntity> payments,
            final Map<Long, List<UserPaymentEntity>> userPaymentsByPaymentId
    ) {
        Map<Integer, List<PaymentEntity>> paymentsByMonth = payments.stream()
                .collect(Collectors.groupingBy(PaymentEntity::getMonth));

        return paymentsByMonth.entrySet().stream()
                .map(entry -> {
                    int month = entry.getKey();
                    List<PaymentEntity> monthPayments = entry.getValue();

                    MonthPaymentDTO summary = new MonthPaymentDTO();
                    summary.setMonth(monthIntToString(month));

                    // Ï§ëÎ≥µ ID Ï†úÍ±∞Î•º ÏúÑÌï¥ Set ÏÇ¨Ïö©
                    Set<Long> paidUserIds = new HashSet<>();
                    Set<Long> debtUserIds = new HashSet<>();

                    for (PaymentEntity payment : monthPayments) {
                        List<UserPaymentEntity> userPayments = userPaymentsByPaymentId.getOrDefault(payment.getId(),
                                List.of());

                        for (UserPaymentEntity userPayment : userPayments) {
                            Long userEntityId = userPayment.getContractMember().getUser().getId();
                            if (userPayment.getStatus() == PaymentStatus.COLLECTED) {
                                paidUserIds.add(userEntityId);
                            } else {
                                debtUserIds.add(userEntityId);
                            }
                        }
                    }

                    summary.setPaidUserIds(new ArrayList<>(paidUserIds));
                    summary.setDebtUserIds(new ArrayList<>(debtUserIds));
                    return summary;
                })
                .collect(Collectors.toList());
    }

    private List<WeekPaymentDTO> getWeekPaymentSummaries(
            final List<PaymentEntity> allUtilityPayments,
            final Map<Long, List<UserPaymentEntity>> userPaymentsByPaymentId
    ) {
        if (allUtilityPayments.isEmpty()) {
            return Collections.emptyList();
        }

        Map<Integer, Map<Integer, List<PaymentEntity>>> groupedByMonthWeek = allUtilityPayments.stream()
                .collect(Collectors.groupingBy(
                        PaymentEntity::getMonth,
                        Collectors.groupingBy(PaymentEntity::getWeek)
                ));

        List<Map.Entry<Integer, Map<Integer, List<PaymentEntity>>>> monthEntries = new ArrayList<>(
                groupedByMonthWeek.entrySet());

        monthEntries.sort(Map.Entry.<Integer, Map<Integer, List<PaymentEntity>>>comparingByKey().reversed());

        List<WeekPaymentDTO> weeklySummaries = new ArrayList<>();

        int weekCount = 0;
        outerLoop:
        for (Map.Entry<Integer, Map<Integer, List<PaymentEntity>>> monthEntry : monthEntries) {
            Integer monthInt = monthEntry.getKey();
            String monthStr = monthIntToString(monthInt);

            List<Map.Entry<Integer, List<PaymentEntity>>> weekEntries = new ArrayList<>(
                    monthEntry.getValue().entrySet());
            weekEntries.sort(Map.Entry.<Integer, List<PaymentEntity>>comparingByKey().reversed());

            for (Map.Entry<Integer, List<PaymentEntity>> weekEntry : weekEntries) {
                if (weekCount >= 6) {
                    break outerLoop;
                }

                Integer week = weekEntry.getKey();
                List<PaymentEntity> weekPayments = weekEntry.getValue(); // Ìï¥Îãπ Ï£ºÏùò PaymentEntity Î¶¨Ïä§Ìä∏

                int weeklyTotalAmount = weekPayments.stream()
                        .mapToInt(PaymentEntity::getTotalAmount)
                        .sum();

                Set<Long> paidUserIds = new HashSet<>();
                Set<Long> debtUserIds = new HashSet<>();

                for (PaymentEntity payment : weekPayments) {
                    List<UserPaymentEntity> userPayments = userPaymentsByPaymentId.getOrDefault(payment.getId(),
                            List.of());
                    for (UserPaymentEntity userPayment : userPayments) {
                        Long userEntityId = userPayment.getContractMember().getUser().getId();
                        if (userPayment.getStatus() == PaymentStatus.COLLECTED
                                || userPayment.getStatus() == PaymentStatus.PAID) {
                            paidUserIds.add(userEntityId);
                            debtUserIds.remove(userEntityId);
                        } else {
                            if (!paidUserIds.contains(userEntityId)) {
                                debtUserIds.add(userEntityId);
                            }
                        }
                    }
                }

                weeklySummaries.add(new WeekPaymentDTO(
                        monthStr,
                        week,
                        weeklyTotalAmount, // Í≥ÑÏÇ∞Îêú Ï£ºÎ≥Ñ Ï¥ùÏï° Ï∂îÍ∞Ä
                        new ArrayList<>(paidUserIds),
                        new ArrayList<>(debtUserIds)
                ));
                weekCount++;
            }
        }
        return weeklySummaries;
    }

    private String monthIntToString(int monthInt) {
        String s = String.valueOf(monthInt);
        if (s.length() != 6) {
            return s;
        }
        String year = s.substring(0, 4);
        String month = s.substring(4);
        // ÏïûÏóê Î∂àÌïÑÏöîÌïú 0Ïù¥ ÏûàÎã§Î©¥ Ï†úÍ±∞
        month = String.valueOf(Integer.parseInt(month));
        return year + "-" + month;
    }

}
